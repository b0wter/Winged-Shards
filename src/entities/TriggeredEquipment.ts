import { Teams } from './Teams'
import { AddProjectileFunc } from '~/scenes/ColliderCollection'
import { Equipment } from './Equipment'
import { CurrentStatusChange } from './StatusChanges'
import GameplayScene from '~/scenes/GameplayScene'
import PhysicalEntity from './PhysicalEntity'
import { IPhysicalEntityProvider, IProviderCollection } from '~/providers/EntityProvider'
import { ILineOfSightProvider } from '~/providers/LineOfSightProdiver'

export type EquipmentCooldownChangedCallback = (equipment: TriggeredEquipment, remainingCooldown: number) => void
export type EquipmentCooldownFinishedCallback = (equipment: TriggeredEquipment) => void

export type EquipmentAngleCallback = () => number
export type EquipmentPositionCallback = (angle: EquipmentAngleCallback) => Phaser.Geom.Point
export type EquipmentNumberOfUsageCallback = (equipment: TriggeredEquipment, usesLeft: number) => void

export abstract class TriggeredEquipment extends Equipment
{
    protected abstract readonly cooldown: number 
    public abstract readonly completeCooldown: number
    public abstract readonly heatPerTrigger: number

    abstract get range() : number

    private lastUsedAt = 0

    protected cooldownModifier = 1

    private readonly cooldownChangedCallbacks : EquipmentCooldownChangedCallback[] = []
    private readonly numberOfUsesCallbacks : EquipmentNumberOfUsageCallback[] = []
    private readonly cooldownFinishedCallbacks: EquipmentCooldownFinishedCallback[] = []

    public readonly statusChangePerSecond = CurrentStatusChange.zero

    public static readonly class: string = "triggered"
    public readonly class: string = TriggeredEquipment.class
    public readonly kind: string = "triggered"

    public abstract get numberOfUses() : number

    private cooldownFinishedOnPreviousUpdate = false

    constructor()
    {
        super()
    }

    /**
     * Attempts to trigger this equipment. Returns the heat generated by that try.
     */
    public trigger(scene: GameplayScene, 
                   colliderFunc: AddProjectileFunc, 
                   equipmentPosition: EquipmentPositionCallback, 
                   angle: EquipmentAngleCallback, 
                   providerCollection: IProviderCollection,
                   time: number, 
                   ownerId: string, 
                   team: Teams) : number
    {
        const passed = time - this.lastUsedAt
        if(passed > this.completeCooldown * this.cooldownModifier && this.canBeTriggered && this.isDestroyed === false) {
            this.internalTrigger(scene, colliderFunc, equipmentPosition, angle, providerCollection, time, ownerId, team)
            this.lastUsedAt = time
            this.cooldownFinishedOnPreviousUpdate = false
            return this.heatPerTrigger
        }
        return 0
    }

    protected abstract get canBeTriggered()

    public update(t: number, dt: number, _)
    {
        this.internalUpdate(t, dt)
        if(this.cooldownFinishedOnPreviousUpdate === false)
        {
            const remainingCooldown = Math.max(0, this.lastUsedAt + this.completeCooldown - t)
            this.cooldownChangedCallbacks.forEach(x => x(this, remainingCooldown))
            if(remainingCooldown === 0)
            {
                this.cooldownFinishedOnPreviousUpdate = true
                this.cooldownFinishedCallbacks.forEach(c => c(this))
            }
        }
        return CurrentStatusChange.zero
    }

    protected abstract internalUpdate(t, dt)

    protected abstract internalTrigger(scene: GameplayScene, 
                                       colliderFunc: AddProjectileFunc, 
                                       equipmentPosition: EquipmentPositionCallback, 
                                       angle: EquipmentAngleCallback, 
                                       providerCollection: IProviderCollection,
                                       time, ownerId: string, team: Teams)

    protected mountOffset()
    {
        return new Phaser.Math.Vector2(0, 0)
    }

    public addCooldownChangedCallback(c: EquipmentCooldownChangedCallback)
    {
        this.cooldownChangedCallbacks.push(c)
    }

    public addCooldownFinishedCallback(c: EquipmentCooldownFinishedCallback)
    {
        this.cooldownFinishedCallbacks.push(c)
    }

    public addNumberOfUsesCallback(c: EquipmentNumberOfUsageCallback)
    {
        this.numberOfUsesCallbacks.push(c)
    }

    public removeCooldownChangedCallback(c: EquipmentCooldownChangedCallback)
    {
        this.cooldownChangedCallbacks.forEach( (item, index) => {
            if(item === c) this.cooldownChangedCallbacks.splice(index,1);
          });
    }

    public removeCooldownFinishedCallback(c: EquipmentCooldownFinishedCallback)
    {
        this.cooldownFinishedCallbacks.forEach( (item, index) => {
            if(item === c) this.cooldownFinishedCallbacks.splice(index,1);
          });
    }

    public removeNumberOfUsesCallback(c: EquipmentNumberOfUsageCallback)
    {
        this.numberOfUsesCallbacks.forEach( (item, index) => {
            if(item === c) this.numberOfUsesCallbacks.splice(index,1);
          });
    }

    protected triggerNumberOfUsesCallbacks(i: number)
    {
        this.numberOfUsesCallbacks.forEach(c => c(this, i))
    }
}

export type TriggeredEquipmentTemplate = () => TriggeredEquipment